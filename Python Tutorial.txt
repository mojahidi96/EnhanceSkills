-----------------The Python Tutorial-------------------
3. An Informal Introduction to Python
-3.1.Using Python as a Calculator
--3.1.1. Numbers
(50 - 5*6) / 4 # division always returns a floating point number
17 // 3
5
17 % 3  # the % operator returns the remainder of the division
2
5 ** 2  # 5 squared ** operator to calculate powers
2 ** 7  # 2 to the power of 7
128
(=) is used to assign a value
width = 20
height = 5 * 9
width * height
900
full support for floating point
4 * 3.75 - 1
14.0
In interactive mode, the last printed expression is assigned to the variable _. --didn't work, missed something

--3.1.2 Strings
Python can also manipulate strings, enclosed in single quotes ('...') or double quotes ("...") and \ can be used to escape quotes:
'doesn\'t'  # use \' to escape the single quote...
s = 'First line.\nSecond line.'
print(s)  # with print(), \n produces a new line
First line.
Second line.
If you don’t want characters prefaced by \ to be interpreted as special characters, you can use raw strings by adding an r before the first quote:
print('C:\some\name')
print(r'C:\some\name')  # note the r before the quote
String literals can span multiple lines. One way is using triple-quotes: """...""" or '''...'''.
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")
Strings can be concatenated (glued together) with the + operator, and repeated with *:
# 3 times 'un', followed by 'ium'
3 * 'un' + 'ium'
'unununium'
Two or more string literals (i.e. the ones enclosed between quotes) next to each other are automatically concatenated.
'Py' 'thon'
text = ('Put several strings within parentheses '
        'to have them joined together.')
--output: 'Put several strings within parentheses to have them joined together.'

This only works with two literals though, not with variables or expressions:
prefix = 'Py'
prefix 'thon'  # error: can't concatenate a variable and a string literal
prefix + 'thon' # use +, works fine
Strings can be indexed (subscripted),
word = 'Python'
word[0]
Indices may also be negative numbers, to start counting from the right:
word[-1]  # last character
word[-2]  # second-last character
Note that since -0 is the same as 0, negative indices start from -1.
slicing is also supported,allows to obtain substring:
word[0:2]  # characters from position 0 (included) to 2 (excluded)
Note how the start is always included, and the end always excluded.
word[:2] + word[2:]
 +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
out of range slice indexes are handled gracefully when used for slicing:
word[4:42]  //on
word[42:]   //''
Python strings cannot be changed — they are immutable.
word[0] = 'J'    //Error: TypeError: 'str' object does not support item assignment
'J' + word[1:]
The built-in function len() returns the length of a string:
len(word)

--3.1.3. Lists
Python knows a number of compound data types, used to group together other values. The most versatile is the list,
Lists might contain items of different types,
squares = [1, 4, 9, 16, 25]
lists can be indexed and sliced
squares[-1]  //25
squares[-3:]  # slicing returns a new list [9, 16, 25]
All slice operations return a new list containing the requested elements. This means that the following slice returns a shallow copy of the list:
squares[:] // [1, 4, 9, 16, 25]
shallow copy: A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.
deep copy: A deep copy constructs a new compound object(objects that contain other objects, like lists or class instances) and then, recursively, inserts copies into it of the objects found in the original.
Lists also support operations like concatenation
squares + [36, 49, 64, 81, 100]  //[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
Unlike strings, which are immutable, lists are a mutable type, i.e. it is possible to change their content
cubes = [1, 8, 27, 65, 125]
cubes[3] = 64  # replace the wrong value  //[1, 8, 27, 64, 125]
You can also add new items at the end of the list, by using the append() method
cubes.append(216)
cubes.append(7 ** 3)  # and the cube of 7
[1, 8, 27, 64, 125, 216, 343]
Assignment to slices is also possible, and this can even change the size of the list or clear it entirely:
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
letters[2:5] = ['C', 'D', 'E'] # replace some values //['a', 'b', 'C', 'D', 'E', 'f', 'g']
letters[2:5] = [] # now remove them // ['a', 'b', 'f', 'g']
letters[:] = []  # clear the list by replacing all the elements with an empty list
len() also applies to lists
It is possible to nest lists
a = ['a', 'b', 'c'];  n = [1, 2, 3]
x = [a, n]   //[['a', 'b', 'c'], [1, 2, 3]]

4. More Control Flow Tools
Besides the while statement just introduced, Python uses the usual flow control statements known from other languages
--4.1. if Statements
x = int(input("Please enter an integer: "))
if x < 0:
    x = 0
    print('Negative changed to zero')-
elif x == 0:
    print('Zero')
elif x == 1:
    print('Single')
else:
    print('More')
The keyword ‘elif’ is short for ‘else if’

--4.2. for Statements
Python’s for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence.
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))
	
user = {"name": "Mojahid", "roll": "1",
        "address": "Hindon Vihar", "active": "active"}
for key, value in user.copy().items():
    if value == "active":
        del user[key]
print(user)
--4.3. The range() Function
sequence of numbers
for i in range(5):
    print(i)
	
range(0, 10, 3)   0, 3, 6, 9

a = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(a)):
    print(i, a[i])

--4.4. break and continue Statements, and else Clauses on Loops
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
    else:
        # loop fell through without finding a factor
        print(n, 'is a prime number')
(Yes, this is the correct code. Look closely: the else clause belongs to the for loop, not the if statement.)
When used with a loop, the else clause has more in common with the else clause of a try statement than it does with that of if statements: a try statement’s else clause runs when no exception occurs, and a loop’s else clause runs when no break occurs. For more on the try statement and exceptions,
The continue statement, also borrowed from C, continues with the next iteration of the loop:
for num in range(2, 10):
    if num % 2 == 0:
        print("Found an even number", num)
        continue
    print("Found a number", num)

--4.5. pass Statements
The pass statement does nothing. It can be used when a statement is required syntactically but the program requires no action.
while True:
    pass  # Busy-wait for keyboard interrupt (Ctrl+C)
This is commonly used for creating minimal classes:
--4.6. Defining Functions
def fib(n):    # write Fibonacci series up to n
    """Print a Fibonacci series up to n."""
    a, b = 0, 1
    while a < n:
        print(a, end='          ')
        a, b = b, a+b
    print()

fib(200)

-4.7. More on Defining Functions
It is also possible to define functions with a variable number of arguments. There are three forms, which can be combined.
--4.7.1. Default Argument Values
The most useful form is to specify a default value for one or more arguments. 
def ask_ok_one(prompt, retries=4, reminder='Please try again'):
    while True:
        ok = input(prompt)
        if ok in ('y', 'ye', 'yes'):
            return True
        if ok in ('n', 'no', 'nop', 'nope'):
            return False
        retries = retries - 1
        if retries < 0:
            raise ValueError('Invalid user response')
        print(reminder)

ask_ok_one('OK to overwrite the file?', 2, 'Come on, only yes or no!')
The default values are evaluated at the point of function definition in the defining scope, so that
i = 5
def f(arg=i):
    print(arg)

i = 6
f()   //output 5
Important warning: The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes. For example, the following function accumulates the arguments passed to it on subsequent calls:
def f(a, L=[]):
    L.append(a)
    return L

print(f(1))  //[1]
print(f(2))  //[1, 2]
print(f(3))  //[1, 2, 3]

--4.7.2. Keyword Arguments
 
